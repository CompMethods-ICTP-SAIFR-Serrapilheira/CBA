std <- sd(x) / sqrt(length(x))
if (round) std <- round(std, ...)
return(std)
}
std(envir$Clay, round = TRUE, digits = 2)
envir_std <- apply(envir[, -1], 2, std, round = TRUE, digits = 2)
envir_tbl <- data.frame(variable = names(envir_mean),
mean = round(envir_mean, 2),
std = envir_std, row.names = NULL)
# Writing summary table
if (!dir.exists("output/")) dir.create("output/", recursive = TRUE)
write.csv(envir_tbl,
"output/02_envir_summary.csv", row.names = FALSE)
# Species vs sites table
head(data_list$comm)
comm <- data_list$comm
head(comm)
# Sum of species abundances across sites
comm_sum <- apply(comm[, -1], 2, sum)
colSums(comm[, -1])
# Plotting a species abundance curve
plot(sort(comm_sum, decreasing = TRUE), las = 1, bty = "l",
xlab = "Species", ylab = "Abundance")
# Exporting the figure
res <- 300
fig_size <- (res * 240) / 72
if (!dir.exists("figs")) dir.create("figs")
png("figs/02_species_abundance.png",
res = res,
height = fig_size,
width = 1.5 * fig_size)
plot(sort(comm_sum, decreasing = TRUE), las = 1, bty = "l",
xlab = "Species", ylab = "Abundance")
text(substitute(paste(italic("Bolboschoenus maritimus"))), x = 14, y = 126,
cex = 0.8)
text(substitute(paste(italic("Phalaris coerulescens"))), x = 14, y = 80,
cex = 0.8)
dev.off()
# for loop in R ----------------------------------------------------------------
comm_df <- as.data.frame(comm_sum)
comm_df$TaxonName <- NA
for (sp in rownames(comm_df)) {
comm_df[sp, "TaxonName"] <- data_list$splist$TaxonName[data_list$splist$TaxCode == sp]
}
ggit@github.com:salmeronamanda/Scientific-Programming.git
git@github.com:salmeronamanda/Scientific-Programming.git
git remote add origin git@github.com:salmeronamanda/Scientific-Programming.git
git commit
}
#commit
}
git commit
library(dplyr)
library(ggplot2)
library(lubridate)
library(zoo)
covid <- read.csv("data/raw/covid19-dd7bc8e57412439098d9b25129ae6f35.csv")
# First checking the class
class(covid$date)
# Changing to date format
covid$date <- as_date(covid$date)
# Checking the class
class(covid$date)
# Now we can make numeric operations
range(covid$date)
ggplot(covid) +
geom_line(aes(x = date, y = new_confirmed)) +
theme_minimal()
covid$new_confirmed[covid$new_confirmed < 0] <- 0
ggplot(covid) +
geom_line(aes(x = date, y = new_confirmed)) +
theme_minimal() +
labs(x = "Date", y = "New cases")
library(sf)
library(tmap)
library(dplyr)
data(World)
# package tmap has a syntax similar to ggplot. The functions start all with tm_
tm_shape(World) +
tm_borders()
#head(World)
names(World)
class(World)
dplyr::glimpse(World)
plot(World[1])
plot(World[,1])
plot(World[1,])
plot(World["pop_est"])
head(World[, 1:4])
class(World)
class(World$geometry)
head(sf::st_coordinates(World))
no_geom <- sf::st_drop_geometry(World)
class(no_geom)
#bounding boxes
st_bbox(World)
names(World)
unique(World$continent)
World %>%
filter(continent == "South America") %>%
tm_shape() +
tm_borders()
World %>%
mutate(our_countries = if_else(iso_a3 %in% c("COL","BRA", "MEX"), "red", "grey")) %>%
tm_shape() +
tm_borders() +
tm_fill(col = "our_countries") +
tm_add_legend("fill",
"Countries",
col = "red")
#install.packages("rnaturalearth")
#install.packages("remotes")
#remotes::install_github("ropensci/rnaturalearthhires")
library(rnaturalearth)
library(rnaturalearthhires)
bra <- ne_states(country = "brazil", returnclass = "sf")
plot(bra)
dir.create("data/shapefiles", recursive = TRUE)
st_write(obj = bra, dsn = "data/shapefiles/bra.shp", delete_layer = TRUE)
bra2 <- read_sf("data/shapefiles/bra.shp")
class(bra)
class(bra2)
plot(bra)
plot(bra2)
library(raster)
dir.create(path = "data/raster/", recursive = TRUE)
tmax_data <- getData(name = "worldclim", var = "tmax", res = 10, path = "data/raster/")
plot(tmax_data)
is(tmax_data) #the data are a raster stack, several rasters piled
dim(tmax_data)
extent(tmax_data)
res(tmax_data)
install.packages("rgbif")
install.packages("Taxonstand")
install.packages("CoordinateCleaner")
install.packages("maps")
library(rgbif)
library(Taxonstand)
library(CoordinateCleaner)
library(maps)
library(rgbif)
library(dplyr)
species <- "Myrsine coriacea"
occs <- occ_search(scientificName = species,
limit = 100000,
basisOfRecord = "PRESERVED_SPECIMEN")
names(occs)
myrsine.data <- occs$data
colnames(myrsine.data)
dir.create("data/raw/", recursive = TRUE)
write.csv(myrsine.data,
"data/raw/myrsine_data.csv",
row.names = FALSE)
sort(unique(myrsine.data$scientificName))
table(myrsine.data$taxonomicStatus)
table(myrsine.data$scientificName, myrsine.data$taxonomicStatus)
species.names <- unique(myrsine.data$scientificName)
dim(species.names)
tax.check <- TPL(species.names)
tax.check
# creating new object w/ original and new names after TPL
new.tax <- data.frame(scientificName = species.names,
genus.new.TPL = tax.check$New.Genus,
species.new.TPL = tax.check$New.Species,
status.TPL = tax.check$Taxonomic.status,
scientificName.new.TPL = paste(tax.check$New.Genus,
tax.check$New.Species))
# now we are merging raw data and checked data
myrsine.new.tax <- merge(myrsine.data, new.tax, by = "scientificName")
dir.create("data/processed/", recursive = TRUE)
write.csv(myrsine.new.tax,
"data/processed/data_taxonomy_check.csv",
row.names = FALSE)
plot(decimalLatitude ~ decimalLongitude, data = myrsine.data, asp = 1)
map(, , , add = TRUE)
myrsine.coord <- myrsine.data[!is.na(myrsine.data$decimalLatitude)
& !is.na(myrsine.data$decimalLongitude),]
# output w/ only potential correct coordinates
geo.clean <- clean_coordinates(x = myrsine.coord,
lon = "decimalLongitude",
lat = "decimalLatitude",
species = "species",
value = "clean")
table(myrsine.coord$country)
par(mfrow = c(1, 2))
plot(decimalLatitude ~ decimalLongitude, data = myrsine.data, asp = 1)
map(, , , add = TRUE)
plot(decimalLatitude ~ decimalLongitude, data = geo.clean, asp = 1)
map(, , , add = TRUE)
par(mfrow = c(1, 1))
myrsine.new.geo <- clean_coordinates(x = myrsine.coord,
lon = "decimalLongitude",
lat = "decimalLatitude",
species = "species",
value = "spatialvalid")
table(myrsine.new.geo$.summary)
tail(names(myrsine.new.geo))
# merging w/ original data
dim(myrsine.data)
dim(myrsine.new.geo)
myrsine.new.geo2 <- merge(myrsine.data, myrsine.new.geo,
all.x = TRUE)
dim(myrsine.new.geo2)
full_join(myrsine.data, myrsine.new.geo)
plot(decimalLatitude ~ decimalLongitude, data = myrsine.new.geo2, asp = 1,
col = if_else(myrsine.new.geo2$.summary, "green", "red"))
map(, , , add = TRUE)
write.csv(myrsine.new.geo2,
"data/processed/myrsine_coordinate_check.csv",
row.names = FALSE)
library(tmap)
library(sf)
myrsine.final <- left_join(myrsine.coord, myrsine.new.geo2)
nrow(myrsine.final)
myrsine_sf <- st_as_sf(myrsine.final, coords = c("decimalLongitude", "decimalLatitude"))
st_crs(myrsine_sf)
myrsine_sf <- st_set_crs(myrsine_sf, 4326)
st_crs(myrsine_sf)
#dir.create("data/shapefiles", recursive = T)
data(World)
SAm_map <- World %>%
filter(continent %in% c("South America", "North America")) %>%
tm_shape() +
tm_borders()
SAm_map +
tm_shape(myrsine_sf) +
tm_bubbles(size = 0.2,
col = ".summary")
tmap_mode("view")
World %>%
filter(continent %in% c("South America", "North America")) %>%
tm_shape() +
tm_borders() +
tm_shape(myrsine_sf) +
tm_bubbles(size = 0.2)
install.packages("vegan")
comm <- read.csv("data/raw/cestes/comm.csv")
dim(comm)
head(comm[,1:6])
#most abundant specie
comm <- as.data.frame(comm)
#most abundant specie
comm <- as.data.frame(comm)
sort(apply(comm[,-1], 2, sum), decreasing = T)
comm_sorted <- sort(colSums(comm), decreasing=TRUE)
comm_sorted[2:6]
install.packages("vegan")
comm <- read.csv("data/raw/cestes/comm.csv")
dim(comm)
head(comm[,1:6])
#most abundant specie
comm_sorted <- sort(colSums(comm), decreasing=TRUE)
comm_sorted[2:6]
#richness
boolean_comm <- comm != 0
comm$number_of_species = rowSums(boolean_comm != 0)-1
library(ggplot2)
ggplot(data=comm, aes(x=Sites,y=number_of_species)) +
geom_bar(stat="identity")
#
#richness
boolean_comm <- comm != 0
comm$number_of_species = rowSums(boolean_comm != 0)-1
library(ggplot2)
ggplot(data=comm, aes(x=Sites,y=number_of_species)) +
geom_bar(stat="identity")
siteabund <- rowSums(comm2)
comm3 <- cbind(comm3, siteabund)
View(siteabund)
comm_siteabund <- data.frame(comm3$Sites,comm3$siteabund)
comm_siteabund[order(comm_siteabund$comm3.siteabund),]
tail(comm_siteabund)
comm_binary=comm[,-1]
comm_binary[comm_binary > 0] <- 1
species_site=rowSums(comm_binary)
#most abundant specie in each site
comm_sitesp <- subset(comm, select = -Sites)
for (i in 1:length(comm_sitesp)){
max(comm_sitesp[i,])
spmost <-  which (comm_sitesp[i,] == max (comm_sitesp[i,]))
print(spmost)
}
install.packages("vegan")
comm <- read.csv("data/raw/cestes/comm.csv")
dim(comm)
head(comm[,1:6])
#five most abundant species
comm_sorted <- sort(colSums(comm), decreasing=TRUE)
comm_sorted[2:6]
#richness
boolean_comm <- comm != 0
comm$number_of_species = rowSums(boolean_comm != 0)-1
library(ggplot2)
ggplot(data=comm, aes(x=Sites,y=number_of_species)) +
geom_bar(stat="identity")
#most abundant specie in each site
comm_sitesp <- subset(comm, select = -Sites)
for (i in 1:length(comm_sitesp)){
max(comm_sitesp[i,])
spmost <-  which (comm_sitesp[i,] == max (comm_sitesp[i,]))
print(spmost)
}
install.packages("vegan")
install.packages("FD")
install.packages("ape")
install.packages("phytools")
head(comm)[,1:6]
head(traits)[,1:6]
rownames(comm)[1:6]
rownames(comm) <- paste0("Site", comm[,1])
comm <- comm[,-1]
head(comm)[,1:6]
head(traits)[,1:6]
library(vegan)
richness <- vegan::specnumber(comm)
shannon <- vegan::diversity(comm)
simpson <- vegan::diversity(comm, index = "simpson")
library(cluster)
library(FD)
gow <- cluster::daisy(traits, metric = "gower")
gow2 <- FD::gowdis(traits)
#implementations in R vary and the literature reports extensions and modifications
identical(gow, gow2) #not the same but why?
gow <- cluster::daisy(traits, metric = "gower")
gow2 <- FD::gowdis(traits)
#implementations in R vary and the literature reports extensions and modifications
identical(gow, gow2) #not the same but why?
class(gow) #different classes
gow <- cluster::daisy(traits, metric = "gower")
class(gow) #different classes
class(gow2)
plot(gow, gow2, asp = 1) #same values
#install.packages(SYNCSA)
library(SYNCSA)
tax <- rao.diversity(comm)
fun <- rao.diversity(comm, traits = traits)
#plot(fun$Simpson,fun$FunRao, pch = 19, asp = 1)
#install.packages(SYNCSA)
library(SYNCSA)
#install.packages("FD")
library(FD)
#we can use the distance matrix to calculate functional diversity indices
FuncDiv1 <- dbFD(x = gow, a = comm, messages = F)
#the returned object has Villéger's indices and Rao calculation
names(FuncDiv1)
install.packages("vegan")
head(comm)[,1:6]
head(traits)[,1:6]
rownames(comm)[1:6]
rownames(comm) <- paste0("Site", comm[,1])
comm <- comm[,-1]
head(comm)[,1:6]
head(traits)[,1:6]
library(vegan)
richness <- vegan::specnumber(comm)
shannon <- vegan::diversity(comm)
simpson <- vegan::diversity(comm, index = "simpson")
library(cluster)
library(FD)
gow <- cluster::daisy(traits, metric = "gower")
gow2 <- FD::gowdis(traits)
#implementations in R vary and the literature reports extensions and modifications
identical(gow, gow2) #not the same but why?
class(gow) #different classes
class(gow2)
plot(gow, gow2, asp = 1) #same values
#install.packages(SYNCSA)
library(SYNCSA)
tax <- rao.diversity(comm)
fun <- rao.diversity(comm, traits = traits)
#install.packages("FD")
library(FD)
#we can use the distance matrix to calculate functional diversity indices
FuncDiv1 <- dbFD(x = gow, a = comm, messages = F)
#the returned object has Villéger's indices and Rao calculation
names(FuncDiv1)
install.packages("vegan")
install.packages("FD")
install.packages("ape")
install.packages("phytools")
head(comm)[,1:6]
head(traits)[,1:6]
rownames(comm)[1:6]
rownames(comm) <- paste0("Site", comm[,1])
comm <- comm[,-1]
head(comm)[,1:6]
head(traits)[,1:6]
library(vegan)
richness <- vegan::specnumber(comm)
shannon <- vegan::diversity(comm)
simpson <- vegan::diversity(comm, index = "simpson")
library(cluster)
library(FD)
gow <- cluster::daisy(traits, metric = "gower")
gow2 <- FD::gowdis(traits)
#implementations in R vary and the literature reports extensions and modifications
identical(gow, gow2) #not the same but why?
class(gow) #different classes
class(gow2)
plot(gow, gow2, asp = 1) #same values
#install.packages(SYNCSA)
library(SYNCSA)
tax <- rao.diversity(comm)
fun <- rao.diversity(comm, traits = traits)
#install.packages("FD")
library(FD)
#we can use the distance matrix to calculate functional diversity indices
FuncDiv1 <- dbFD(x = gow, a = comm, messages = F)
#the returned object has Villéger's indices and Rao calculation
names(FuncDiv1)
library(vegan)
data(dune)
data(dune.env)
table(dune.env$Management)
library(vegan)
data(dune)
data(dune.env)
table(dune.env$Management)
bray_distance <- vegdist(dune)
# Chord distance, euclidean distance normalized to 1.
chord_distance <- dist(decostand(dune, "norm"))
library(cluster)
b_cluster <- hclust(bray_distance, method = "average")
c_cluster <- hclust(chord_distance, method = "average")
par(mfrow = c(1, 2))
plot(b_cluster)
plot(c_cluster)
par(mfrow = c(1, 1))
par(mfrow = c(1, 2))
plot(b_cluster, hang = -1, main = "", axes = F)
axis(2, at = seq(0, 1, 0.1), labels = seq(0, 1, 0.1), las = 2)
plot(c_cluster, hang = -1, main = "", axes = F)
axis(2, at = seq(0, 1, 0.1), labels = seq(0, 1, 0.1), las = 2)
par(mfrow = c(1, 1))
library(vegan)
tabela <- read.csv("data/raw/cestes/comm.csv", sep = ",", head = T)
shannon_sites = c()
for(i in seq(1,nrow(tabela))){
temp_diversity_shannon <- diversity(tabela[i,2:57], index = "shannon")
shannon_sites <- append(shannon_sites, temp_diversity_shannon)
}
tabela_shannon <- data.frame(sites, shannon_sites)
names(tabela_shannon)[2] <- "Shannon Diversity Index"
names(tabela_shannon)[1] <- "Site"
tabela_shannon
simpson_sites = c()
for(i in seq(1,nrow(tabela))){
temp_diversity_simpson <- diversity(tabela[i,2:57], index = "simpson")
simpson_sites <- append(simpson_sites, temp_diversity_simpson)
}
tabela_simpson <- data.frame(sites, simpson_sites)
names(tabela_simpson)[2] <- "Simpson's Diversity Index"
names(tabela_simpson)[1] <- "Site"
tabela_simpson
invsimpson_sites = c()
for(i in seq(1,nrow(tabela))){
temp_diversity_invsimpson <- diversity(tabela[i,2:57], index = "invsimpson")
invsimpson_sites <- append(invsimpson_sites, temp_diversity_invsimpson)
}
tabela_invsimpson <- data.frame(sites, invsimpson_sites)
names(tabela_invsimpson)[2] <- "Inverse Simpson's Diversity Index"
names(tabela_invsimpson)[1] <- "Site"
tabela_invsimpson
shannon_diversity <- function(comm) {
sp <- ncol(comm) - 1
H <- 0
N <- sum(comm[,2:sp + 1])
for(i in seq(1, sp)){
p <- sum(comm[,i + 1]) / N
Hi <- p * log( p )
H <- H - Hi
}
return(H)
}
shannon_diversity()
install.packages("devtools")
install.packages("usethis")
install.packages("available")
devtools::has_devel()
usethis::create_package("../foo")
remotes::install_github("ThinkR-open/remedy")
1
ref.bib
---
title: "Aula 15 - ref"
author: "Amanda Salmeron"
date: '2022-08-11'
output: pdf_document
---
## R Markdown
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.
When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:
```{r cars}
summary(cars)
## Including Plots
You can also embed plots, for example:
```{r pressure, echo=FALSE}
plot(pressure)
Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
@article{Douezan2011,
abstract = {We study the spreading of spheroidal aggregates of cells, expressing a tunable level of E-cadherin molecules, on glass substrates decorated with mixed fibronectin and polyethylene glycol. We observe the contact area by optical interferometry and the profile by side-view microscopy. We find a universal law of aggregate spreading at short times, which we interpret through an analogy with the spreading of viscoelastic droplets. At long times, we observe either partial wetting or complete wetting, with a precursor film of cells spreading around the aggregate with two possible states. In strongly cohesive aggregates this film is a cellular mono-layer in the liquid state, whereas in weakly cohesive aggregates, cells escape from the aggregate, forming a 2D gas. The escape of isolated cells is a physical mechanism that appears also to be present in the progression of a noninvasive tumor into a metastatic malignant carcinoma, known as the epithelial-mesenchymal transition. collective migration | cell adhesion | tissue viscoelasticity | tumor invasion T issue spreading is a fundamental process in embryonic development (1-3), wound healing (4), and cancer invasion and propagation. A tumor is not malignant if it remains cohesive. Understanding how noninvasive tumor cells become metastatic is the most prominent challenge in current cancer research. The first step of cancer propagation (invasion) is characterized by a loss of cell adhesion associated to an increase in cell motility, followed by an entry into blood circulation (intravasation), an escape into a new tissue (extravasation), and the proliferation leading to a secondary tumor (5). The loss of cell adhesion, characteristic of aggressive metastatic cancer, is analogous to that of the epithelial-mesenchymal transition (EMT) during embryonic development (6, 7), which is a key process during gastrulation (8) or neural crest development (9). A repression of E-cadherin expression (involved in the formation of adherens junctions between cells mediated by homophilic ligation in the presence of calcium) has been reported for cells undergoing an EMT transition (10). Here we study the role of E-cadherin expression in the wetting behavior of tissues. We use as a model system cellular aggregates of variable cohesivity, spreading on glass substrates of variable adhesivity. Spherical cellular aggregates are useful in vitro systems to study the properties of tissues. The characterization of tissue mechanics through viscosity has been debated since the pioneering work of Steinberg. He demonstrated that embryonic tissues behave like liquids and are characterized by a well-defined surface tension (11). Mixing cells of two tissues, he observed cell sorting: The tissue with the lower surface tension surrounds the tissue with a higher tension (12-14). If two aggregates are brought in contact, they coalesce to form a single, larger spheroid. The fusion of two aggregates (15, 16) leads to the determination of the capillary velocity V Ã ¼ γ∕η, where γ is the surface tension and η is the viscosity. Compressed between two plates, aggregates behave as viscoelastic droplets. From the measurement of the force versus time, one can derive the elastic modulus at short times and the surface tension at long times (17-19). A shift from liquid to elastic behavior by increasing the tissue cohesion provided by the extracellular matrix has been recently reported (20). Cell aggregate properties have also been characterized by aspiration into a pipette (21). Above a threshold pressure, the dynamics of penetration into the pipette exhibits an elastic behavior at short time scales, and a viscous behavior at long time scales. The aspiration dynamics leads to a measurement of the surface tension γ and the viscosity η. We can conclude from these experiments that tissues are "transient" foams, and flow at long time like viscoelastic pastes. Ryan et al. (22) analyzed the competition between cell-cell and cell-substrate adhesion on tissue spreading. Here we pursue this approach by studying quantitatively the spreading of tissues with different levels of E-cadherin. We interpret our observations in the framework of statics and dynamics of wetting (23). We have used murin sarcoma (S-180) cell lines transfected to express various levels of E-cadherin molecules at the surface of the cells (24), thereby controlling the intercellular adhesion energy. The level of E-cadherin expression is denoted by ϕ, where the most adhesive cell line is defined as ϕ ¼ 100%. We also use cell lines with ϕ ¼ 48% and ϕ ¼ 21%, which express, respectively, a level of E-cadherin of 48% and 21% of the most adhesive cell line. The cell-cell adhesion energy per unit area W CC deduced from the separation force (24) varies approximately with the square of ϕ. As the substrate, we use glass coverslips decorated with a mixture of fibronectin and PEG-poly-L-lysine (PEG-PLL). The cell-substrate adhesion occurs through the binding of integ-rins to fibronectin (25). Integrins are receptors that mediate attachment of a cell by specific binding with the extracellular matrix components. The fraction of fibronectin x (in number of molecules) varies from 0% to 100%, allowing the cell-substrate adhesion energy per unit area W CS to vary in a broad range. When an aggregate is put into contact with the substrate, we observe two regimes: either partial wetting where the aggregate forms at equilibrium a spherical cap, with an equilibrium contact angle; or complete wetting, where the aggregate spreads totally, surrounded by a precursor film. These two regimes are distinguished by the sign of the spreading coefficient, S ¼ γ SO − ðγ CS þ γÞ, where γ SO , γ CS , and γ are, respectively, the substrate-medium, cell-substrate, and tissue interfacial energies shown in Fig. 1A. Introducing the cell-substrate adhesion energy per unit area W CS , we can write γ CS ¼ ðγ SO þ γÞ − W CS. This expresses the energy conservation when a cell-substrate interface is formed from a substrate-medium and a cell-medium interface. Similarly,},
author = {Stéphane Douezan and Karine Guevorkian and Randa Naouar and Sylvie Dufour and Damien Cuvelier and Françoise Brochard-Wyart},
doi = {10.1073/pnas.1018057108/-/DCSupplemental},
journal = {PNAS},
title = {Spreading dynamics and wetting transition of cellular aggregates},
volume = {108},
year = {2011},
}
remotes::install_github(shannon)
remotes::install_github(foo)
